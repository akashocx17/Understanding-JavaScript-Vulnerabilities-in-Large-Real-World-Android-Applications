
[Understanding](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[ ](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[JavaScript](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[ ](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[Vulnerabilities](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[ ](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[in](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[ ](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[Large](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[ ](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[Real-World](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[ ](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[Android
](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)[Applications](https://www.researchgate.net/publication/325702058_Understanding_JavaScript_Vulnerabilities_in_Large_Real-World_Android_Applications?enrichId=rgreq-3d337112b9d71181989a4cd839b14078-XXX&enrichSource=Y292ZXJQYWdlOzMyNTcwMjA1ODtBUzo2Mzg4MDY1NzEwOTQwMThAMTUyOTMxNDc2Mzk5MQ%3D%3D&el=1_x_3&_esc=publicationCoverPdf)

Abstract—JavaScript-related vulnerabilities are becoming a major security threat to hybrid mobile applications. In this article, we present a
systematic study to understand how JavaScript is used in real-world Android apps and how it may lead to security vulnerabilities. We begin
by conducting an empirical study on the top-100 most popular Android apps to investigate JavaScript usage and its related security
vulnerabilities. Our study identiﬁes four categories of JavaScript usage and ﬁnds that three of these categories, if inappropriately used, can
respectively lead to three types of vulnerabilities. We also design and implement an automatic tool named JSDroid to detect
JavaScript-related vulnerabilities. We have applied JSDroid to 1,000 large real-world Android apps and found that over 70% of these apps
have potential JavaScript-related vulnerabilities and 20% of them can be successfully exploited. Moreover, based on the vulnerabilities
identiﬁed by JSDroid, we have successfully launched real attacks on 30 real-world apps.

Index Terms—Android apps, JavaScript, WebView, security vulnerabilities, empirical study

!

1 INTRODUCTION

||<p></p><p> In recent years, hybrid mobile applications (apps) have be-</p><p>` `come increasingly popular [1]. These apps are built with</p><p>a mixture of mobile client languages, such as Java and C,</p><p>and Web technologies, such as HTML, CSS, and JavaScript,</p><p>thus allowing developers to reuse existing Web development</p><p>solutions in different mobile platforms, e.g., Android, iOS,</p><p>Windows, and so forth.</p><p>` `Along with the popularity of hybrid apps, the interaction</p><p>between different languages broadens the attack surface of</p><p>mobile apps. In particular, the dynamic nature of JavaScript</p><p>makes it challenging to ensure that its interaction with the</p><p>remainder of the system is safe and secure. Researchers have</p><p>reported various JavaScript-related security vulnerabilities in</p><p>popular apps. For example, the core WebView component</p><p>` `(which enables JavaScript) may suffer from universal cross-</p><p>` `site scripting (UXSS) attacks [2], malicious JavaScript code</p><p>` `in a browser may perform remote code execution on user</p><p>` `devices by invoking the Java code [3], and if JavaScript accesses</p><p>` `to an execution context are inappropriately controlled, cross-</p><p>` `zone JavaScript code in a local HTML ﬁle may access private</p><p>` `data [4]. For an app with such vulnerabilities, a malware is not</p><p>` `necessarily needed to launch the attack; sometimes a link (an</p><p>` `HTML ﬁle that contains malicious JavaScript) is sufﬁcient. If</p><p>` `the user clicks the link in the app, then the malicious JavaScript</p><p>` `is executed, and the app is attacked.</p><p>` `Although JavaScript security in Android has attracted at-</p><p>tention from the research community, little work has been</p><p>performed to systematically study JavaScript usage and its</p><p>vulnerabilities in real-world Android apps. For example, it is</p><p>unknown how JavaScript is used in popular apps, what are the</p><p>common usage patterns, what types of vulnerabilities can be</p><p>• W. Song and Q. Huang are with the School of Computer Science and</p><p>Engineering, Nanjing University of Science and Technology, Nanjing, China,</p><p>210094\. E-mail: wsong@njust.edu.cn, staryellow20151010@gmail.com.</p><p>• J. Huang is with the Department of Computer Science and Engineering, Texas</p><p>A&M University, E-mail: jeff@cse.tamu.edu.</p>||<p>exposed by using JavaScript, and how such JavaScript-related</p><p>vulnerabilities can be exploited.</p><p>` `In this article, we present a systematic study of 1,000</p><p>large real-world apps from the Android market and report</p><p>our ﬁndings. We begin by conducting a manual study of the</p><p>top-100 most popular apps (e.g., Gmail, Facebook, and Twitter)</p><p>` `and ﬁnd that the uses of JavaScript can be categorized into</p><p>` `only four types and that inappropriate uses of the ﬁrst three</p><p>` `types can respectively lead to three types of vulnerabilities.</p><p>` `Based on our ﬁndings, we develop an automatic tool called</p><p>` `JSDroid that can detect common JavaScript usage patterns in</p><p>` `Android apps and reveal their potential vulnerabilities based</p><p>` `on a static analysis. We apply JSDroid to 1,000 large real-world</p><p>` `apps and ﬁnd that 708 of these apps have potential JavaScript-</p><p>` `related vulnerabilities and that 201 of them can be successfully</p><p>` `exploited. Moreover, based on the identiﬁed vulnerabilities, we</p><p>` `have successfully exploited 30 real-world apps.</p><p>Speciﬁcally, this paper provides two main contributions:</p><p>• We present a comprehensive characterization of</p><p>JavaScript usage and JavaScript-related vulnerabilities</p><p>in Android mobile apps based on an empirical study</p><p>of the top-100 most popular Android apps. To our</p><p>best knowledge, this work is the ﬁrst comprehensive</p><p>study of JavaScript security in large real-world Android</p><p>hybrid apps. Our study not only sheds light on the</p><p>current status of Android security but also provides</p><p>insights to developers on how to appropriately use</p><p>JavaScript in the development of Android apps.</p><p>• We present a static analysis tool named JSDroid that</p><p>can automatically detect JavaScript-related vulnerabili-</p><p>` `ties, and we apply it to 1,000 real-world Android apps.</p><p>` `Our results show that newer Android versions reduce</p><p>` `JavaScript-related vulnerabilities, but many existing de-</p><p>` `vices are still vulnerable. JSDroid is open source and</p><p>publicly available at <http://bit.ly/myJSDroid>.</p><p>` `The remainder of this article is organized as follows.</p><p>Section 2 introduces preliminaries. Section 3 summarizes</p>|
| :- | :- | :- | :- |
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br3"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 2

` `TABLE 1
 APIs Related to WebView and Its Customization
Class Function API
 loadUrl()

Web contents display loadData()

` `loadDataWithBaseURL()
WebView

JavaScript-Java interaction addJavascriptInterface() Get a settings manager getSettings()

Get an event handler setWebViewClient()
JavaScript execution setJavaScriptEnabled()

` `setAllowFileAccess()
WebSettings

File zone access setAllowFileAccessFromFileURLs()

setAllowUniversalAccessFromFileURLs() WebViewClient Page navigation shouldOverrideUrlLoading()

||<p>` `JavaScript usage patterns and related vulnerabilities, and Sec-</p><p>tion 4 characterizes such patterns and vulnerabilities in the</p><p>top-100 apps. Section 5 presents our evaluation on 1,000 large</p><p>real-world apps. Section 6 proposes our exploitations of the</p><p>identiﬁed JavaScript-related vulnerabilities in 30 real-world</p><p>apps. Section 7 discusses how to reduce JavaScript vulnerabil-</p><p>ities in practice. Section 8 reviews related work, and Section 9</p><p>concludes the paper.</p>||<p>Navigable</p><p>` `WebView</p>||<p>A WebView attached</p><p>` `to a WebViewClient</p>|||||
| :- | :- | :- | :- | :- | :- | :- | :- | :- | :- |

|No||<p>shouldOverride</p><p>` `UrlLoading()</p><p>` `overridden?</p>|
| :- | :- | :- |

||||||||<p>WebView</p><p>Yes No</p><p>` `WebViewClient</p><p>atttached?</p><p>Yes</p><p>` `A WebView attached a</p><p>` `WebViewClient overriding</p><p>shouldOverrideUrlLoading()</p>||<p>Non-navigable</p><p>` `WebView</p>|
| :- | :- | :- | :- | :- | :- | :- | :- | :- | :- |
||2 PRELIMINARIES||loadUrl(url) Super()||Return false Others|
||<p>The use of JavaScript in Android apps is closely related to We-</p><p>bView, which is a browser-like view that displays Web contents</p><p>and establishes the interaction between JavaScript and Java. In</p><p>this section, we introduce WebView and its customization.</p>||<p>Navigable</p><p>` `WebView</p><p>Navigable</p><p>` `WebView</p><p>Navigable</p><p>` `WebView</p><p>Fig. 1. Decision tree of WebView navigability.</p>||<p>Non-navigable</p><p>` `WebView</p>|
||<p>2\.1 WebView</p><p>WebView is a subclass of the Android View class designed for</p><p>displaying webpages and executing JavaScript. Prior to KitKat</p><p>(Android 4.4), WebView used the WebKit1 rendering engine to</p><p>` `render webpages. Since KitKat, WebView has used Blink2.</p><p>` `Table 1 summarizes WebView-related classes and their</p><p>` `APIs. There are two ways to create a WebView: one way is</p><p>` `to include a <WebView> element in the layout XML ﬁle of an</p><p>` `activity, and the other is to create a WebView object directly in</p><p>` `the activity initialization. Once a WebView instance is created,</p><p>` `a basic browser is built inside. The ﬁrst three methods of</p><p>` `WebView in Table 1 are used to display Web contents.</p>||<p>• setAllowFileAccess(boolean flag) enables or</p><p>disables ﬁle access within WebView. This only de-</p><p>termines the access to other parts of the ﬁle sys-</p><p>tem, while the assets and resources of apps are</p><p>always accessible via file:///android\_res or</p><p>file:///android\_asset.</p><p>• setAllowFileAccessFromFileURLs(boolean</p><p>` `flag) determines whether the JavaScript code</p><p>running in the context of a ﬁle scheme URL can access</p><p>contents from other ﬁle scheme URLs.</p><p>• setAllowUniversalAccessFromFileURLs(bool-</p><p>` `ean flag) determines whether JavaScript running in</p><p>the context of a ﬁle scheme URL can access contents</p><p>from any other scheme (ﬁle, http, https) URLs.</p>|
||<p>2\.2 WebView Customization</p><p>Android provides two classes, WebSettings and WebViewClient,</p><p>for developers to customize WebView: WebSettings manages</p><p>the settings for WebView, e.g., whether JavaScript execution</p><p>is enabled. WebViewClient is the event handler of WebView,</p><p>which can specify the page navigation behavior of WebView.</p><p>2\.2.1 JavaScript Execution and Zone Access</p><p>WebSettings is obtained by calling the getSettings()</p><p>method of WebView. Developers can enable JavaScript execu-</p><p>tion and zone access using the following methods of WebSet-</p><p>tings:</p><p>• setJavaScriptEnabled(boolean flag) enables</p><p>or disables JavaScript execution in a webpage.</p><p>1\. https://webkit.org/</p><p>2\. https://www.chromium.org/blink</p>||<p>` `Zones denote the scopes of JavaScript code, including ﬁle</p><p>zones and http(s) zones. The last three methods of WebSettings</p><p>can change the zone access ability of JavaScript. For example,</p><p>scripts in a zone from one origin can be allowed to access</p><p>ﬁles in zones from other origins. However, this may result</p><p>in violations of the same origin policy (SOP) [5]. The origin</p><p>of Web content is deﬁned by its protocol (ﬁle, http, or https),</p><p>domain, and port number. Two pages share the same origin</p><p>if the above three elements are the same. If JavaScript in one</p><p>origin reads or writes DOM (document object model) attributes</p><p>in other origins, then SOP is violated.</p><p>2\.2.2 Page Navigation</p><p>WebView can attach a WebViewClient via its</p><p>method setWebViewClient(). The page navigation</p><p>ability of WebView is determined by the method</p><p>shouldOverrideUrlLoading(WebView view, String</p>|
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br4"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 3

TABLE 2

Top-100 Real-world Most Popular Android Apps

App name Version App name Version App name Version App name Version
 Gmail 5.0.1-1642443 GoogleMaps 8.4.1 Facebook 77.0.0.20.66 YouTube 11.07.59
 Twitter 5.111.0 GoogleTTS 3.8.16 GoogleSearch 5.10.32.16 WhatsAppMessenger 2.16.95
 Viber 6.0.1.13 CleanMaster 5.12.3 ChromeBrowser 51.0.2704.81 GooglePlayGames 3.7.23
 Line 6.3.1 AngryBirds 5.2.0 GoogleDrive 2.4.181.13.34 AvastSecurity 5.2.0
 Skype 7.01.0.669 FruitNinjaFree 2.3.4 GoogleHangouts 8.1.121732641 GoogleStreetView 1.8.1.2
 TempleRun 1.6.1 AdobeReader 16.1.1 FacebookMessenger 72.0.0.16.67 GoogleVoiceSearch 2.1.4
 Instagram 8.2.0 GooglePlayBooks 3.8.37 GooglePlayMovies 3.14.4 TempleRun2 1.24.0.1
 ChatON 3.5.839 MyTalkingTom 3.4.1 GooglePlayMusic 6.9.2919B TalkingTomCat 25.0.1
 Shazam 6.5.1-160520 SamsungPush 1.6.00 SubwaySurfers 1.56.0 PandoraRadio 7.2.1
 Tango 3.22.203462 CandyCrushSaga 1.76.1.1 GoogleTranslate 5.0.0.RC FreeAntiVirus 5.3.0.2
 Pou 1.4.69 CandyCrushSoda 1.67.7 FacebookLite 6.0.0.7.138 GOLauncherEX 2.10
 Zedge 5.2.4 Flipboard 3.3.11 AngryBirdsRio 2.6.1 PicsArtPhoto 5.26.4
 Dropbox 8.2.4 HillClimbRacing 1.29.0 SuperBrightLED 1.0.9 DespicableMe 2.7.3b
 WeChat 6.3.18 MXplayer 1.7.40 GoogleEarth 8.0.2.2334 FarmHeroesSaga 2.52.5
 OperaMini 16.0.2168 KakaoTalk 5.6.8 HPPrintPlugin 2.4-1.3.1-10e BarcodeScanner 4.7.5
 AdobeAIR 20.0.0.233 PoolBilliardsPro 3.3 GoogleTalkback 3.5.2 GooglePlayNews 3.5.2
 eBay 2.8.2.1 CutTheRope 2.6.5 AmazonKindle 4.24.0.27 SamsungPrintService 2.19.16
 BBM 2.13.1.14 DUBatterySaver 4.1.6 ShootBubble 3.42.52.5 AngryBirdsGo! 1.13.9
 HayDay 1.28.146 JetpackJoyride 1.9.6 ClashofClans 8.332.9 AngryBirdsSeasons 6.1.1
 Snapchat 9.30.5.0 ESFileExplorer 4.0.5 GooglePhotos 1.21.0.123 Yahoo!Mail 4.7.4
 Kik 10.6.0.6560 BatteryDoctor 5.11 CMSecurity 2.10.5 WhereIsMyWater 1.9.3.86
 8BallPool 3.5.2 ZombieTsunami 1.7.4 SoundCloud 2016.05.19 Don’tTapTheWhiteTile 4.0.3.5
 Retrica 3.0.6 DragRacing 1.6.75 SpotifyMusic 5.4.0.858 TriviaCrack 2.12.0
 FireFox 46.0.1 BeautifulWidgets 5.7.6 PlantsVsZombies 1.1.60 CameraZOOMFX 6.2.1
 Netﬂix 4.5.1 TuneinRadio 15.5.1 DoodleJump 3.9.4 NovaLauncher 3.3

||<p>` `url) of WebViewClient which decides what action to take</p><p>` `when users click a link in webpages loaded by WebView.</p><p>` `When users click a link, the default behavior is to launch</p><p>` `the device browser. Developers can set WebView as navi-</p><p>` `gable to load the destination URL in WebView. Fig. 1 il-</p><p>` `lustrates the decision tree of this behavior. If the Web-</p><p>` `View does not attach a WebViewClient, then it is non-</p><p>` `navigable; otherwise, the navigability depends on whether</p><p>` `shouldOverrideUrlLoading() of WebViewClient is over-</p><p>ridden. If the method is not overridden, is overridden but</p><p>returns super() or a false value, or if it uses WebView to</p><p>` `load the new URL via loadUrl(url), then the WebView is</p><p>` `navigable; otherwise, it is not navigable.</p><p>Load</p><p>Load</p>|||
| :- | :- | :- | :- |

||WebView||<p>Local</p><p>JavaScript</p>||WebView JavaScript|
| :- | :- | :- | :- | :- | :- |

||<p></p><p>**Android app**</p><p>Android app Website</p><p>(a) Local pattern (b) Remote pattern</p><p>InterfaceName InterfaceName</p><p>Callback</p><p>Add</p><p>WebView</p><p>EvaluateJS</p><p>WebView</p>|||
| :- | :- | :- | :- |

||<p>Load</p><p>**Android app JavaScript**</p>||**Android app JavaScript**|
| :- | :- | :- | :- |

||<p></p><p>(c) JSBridge pattern (d) Callback pattern</p><p>Fig. 2. The four JavaScript usage patterns.</p>||<p>Speciﬁcally, the JS-to-Java bridge can be built by calling</p><p>the method addJavascriptInterface(Object object,</p><p>String name) of WebView which injects a Java object (the</p><p>ﬁrst parameter) into the JavaScript environment such that</p><p>JavaScript code loaded by WebView can invoke methods of</p><p>the Java object via the provided name (the second parameter).</p><p>3 USAGE PATTERNS AND VULNERABILITIES</p><p>` `To understand JavaScript vulnerabilities, we conduct an empir-</p><p>` `ical study of the top-100 most popular Android apps listed on</p><p>` `Wikipedia3. Since the reference list shows more than 100 apps,</p><p>` `we selected the ﬁrst 100 available apps, including 92 free apps</p><p>` `and 8 paid apps. We downloaded the APK (Android Package)</p><p>` `ﬁles of the most recent versions of these apps from APK4Fun4</p><p>and the Google Play Store5 as of May 2016.</p><p>` `Table 2 lists these 100 apps including their names and ver-</p><p>` `sions. It took the authors approximately three person-months</p><p>` `to manually analyze these apps. Since the source code of these</p><p>` `apps is unavailable, we decompile their APK ﬁles into Java</p><p>` `source code with the help of two tools, namely, Dex2Jar6 and</p><p>Apktool7. Android developers often obfuscate their apps by</p><p>replacing the names of classes, methods, and variables with</p><p>random symbols. This practice also makes the decompiled</p><p>code difﬁcult to read. Nevertheless, we could inspect the</p><p>JavaScript code in these apps based on class names that are</p><p>not obfuscated and the JavaScript APIs in Table 1.</p><p>` `Altogether, we identify four categories of JavaScript usage,</p><p>namely, local pattern, remote pattern, JSBridge pattern, and callback</p><p>` `pattern, as illustrated in Fig. 2. These four patterns cover almost</p><p>` `all JavaScript-related APIs in existing Android SDKs. More-</p><p>` `over, we ﬁnd that inappropriate uses of the ﬁrst three patterns</p>|
| :- | :- | :- | :- |
||<p>2\.2.3 JavaScript-Java Interaction</p><p>Android provides a mechanism for building a bridge</p><p>between JavaScript code in webpages and Java code</p><p>in apps, allowing JavaScript code to invoke Java code.</p>||<p>` `3. App List. http://en.wikipedia.org/wiki/List of most downloaded</p><p>Android applications (accessed in May 2016)</p><p>4\. APK4Fun. http://www.apk4fun.com</p><p>5\. Google Play Store. http://play.google.com</p><p>6\. Dex2Jar. http://github.com/pxb1988/dex2jar</p><p>7\. Apktool. http://code.google.com/p/android-apktool</p>|
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br5"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 4

TABLE 3

How the Three JavaScript Usage Patterns Can Lead to Their Related Vulnerabilities

Pattern Vulnerability Attack model Victim version
 Root cause Name Attack vector Attack means

Local Inappropriate File-based cross- file:// browsing Cross-zone All Android versions
pattern JavaScript zone zone vulnerability entrance scripting
 access control

Remote Navigable WebView WebView UXSS http:// browsing Cross-site Versions prior to An-
pattern vulnerability entrance scripting droid 5.0
JSBridge Exposed Java object JS-to-Java interface file:// or Java reﬂection Versions prior to An-
pattern vulnerability http:// browsing abuse droid 4.2
 entrance

file:// browsing request http:// browsing request file:// or http:// browsing request

file:// browsing entrance http:// browsing entrance

file:// or http://browsing entrance

||<p>` `Malicious</p><p>JavaScript</p>||<p>Bypass SOP</p><p>from file:// to file://</p>||<p>**User device**</p><p>Attacks</p><p>` `Malicious</p><p>JavaScript</p><p>` `Java</p><p>reflection</p><p>Malicious</p><p>Cross-site</p><p>Sensitive file</p><p>Scripting</p><p>JavaScript</p><p>Cookie data</p><p>Java Method</p><p>Log</p><p>InterfaceName</p><p>in</p>||||||
| :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :- |
||<p>WebView</p><p>**Android app**</p>||<p>Bypass SOP</p><p>from file:// to http://</p>||<p>Cookie data</p><p>**Website**</p>||<p>WebView</p><p>**Android app**</p>||<p>Username and</p><p>` `password</p>||**Website**||<p>WebView InterfaceObj</p><p>**Android app**</p>|
(a) File-based cross-zone vulnerability. (b) WebView UXSS vulnerability. (c) JS-to-Java vulnerability

Fig. 3. Attack models of the three JavaScript-related vulnerabilities.

||<p>` `can lead to three types of JavaScript-related vulnerabilities, i.e.,</p><p>` `ﬁle-based cross-zone vulnerability, WebView UXSS vulnerability,</p><p>and JS-to-Java interface vulnerability, respectively. These three</p><p>types of vulnerabilities cover and classify all known vulnera-</p><p>bilities reported by existing research [2], [3], [4]. To our best</p><p>knowledge, no approach classiﬁes the vulnerabilities in this</p><p>way. There are two threat models for attackers to exploit these</p><p>vulnerabilities [3], [6]:</p><p>1) Malicious third-party content: The malicious content can</p><p>` `be embedded in local HTML ﬁles from third-parties, local</p><p>` `malware, third-party libraries, subframes (e.g., iframe),</p><p>` `and remote websites, where it may call the app interfaces</p><p>` `in some ways that the developers might not have fore-</p><p>` `casted.</p><p>2) Network attack: If an insecure network (e\.g\., insecure WiFi</p><p>` `hotspot) is used, when an app requests a page via HTTP</p><p>` `in WebView, a man-in-the-middle attacker can return any</p><p>` `page that contains malicious JavaScript as the response.</p><p>` `From the developer’s perspective, the ﬁrst three JavaScript</p><p>usage patterns share a common limitation: the JavaScript</p><p>code loaded by WebView runs in a private background</p><p>thread rather than the UI thread (main thread). To up-</p><p>date UI elements, JavaScript code must be explicitly</p><p>called in the UI thread. To address this limitation, start-</p><p>ing with KitKat (Android 4.4), Google includes a Web-</p><p>View API (i.e., evaluateJavascript(String script,</p><p>ValueCallback<String> resultCallback)) that allows</p><p>executing JavaScript in the UI thread. We refer to this type of</p><p>JavaScript usage as the callback pattern (cf. Fig. 2d). Compared</p><p>with the other three patterns, the callback pattern is more se-</p><p>cure because the returned value from the JavaScript execution</p><p>~~can only be passed to a callback function registered by the~~</p><p>trusted Java code. We do not ﬁnd any vulnerabilities related to</p><p>the callback pattern.</p><p>Table 3 summarizes these patterns and their potential vul-</p>||<p>nerabilities. For each type of vulnerability, we also analyze</p><p>the root cause and discuss the attack model for exploiting the</p><p>vulnerability, as illustrated in Fig. 3. We present these results</p><p>in detail in the following.</p><p>3\.1 Local Pattern and File-based Cross-zone Vulnerability</p><p>3\.1.1 Local Pattern</p><p>Developers often use WebView to load HTML ﬁles in app</p><p>resources and dynamic JavaScript in app code. Since the</p><p>JavaScript code in this case is generated locally, we refer to</p><p>this type of JavaScript usage as the local pattern (cf. Fig. 2a).</p><p>` `The local pattern can be implemented by using either of the</p><p>following three WebView methods: loadUrl(String url),</p><p>loadData(String data, String mimeType,String</p><p>encoding), and loadDataWithBaseURL(String data,</p><p>String mimeType, String encoding, String</p><p>historyUrl). For each method, there are two means to</p><p>generate local JavaScript code: 1) add JavaScript in local</p><p>HTML ﬁles located at “file:///android\_asset” or</p><p>“file:///android\_res”; 2) embed scripts in the internal</p><p>Java code via “javascript:”. As an example, Fig. 4 shows</p><p>these two means using loadUrl().</p><p>myWebView.loadUrl("file:///android\_asset/index.html");</p><p>myWebView.loadUrl("javascript:alert(’Hello,JS’)");</p><p>Fig. 4. Two examples of the local pattern.</p><p>3\.1.2 File-based Cross-zone Vulnerability</p><p>The ﬁle-based cross-zone vulnerability will be introduced if ﬁle</p><p>system access within WebView is allowed because SOP can be</p><p>compromised through the following two means:</p><p>• The invocation of setAllowFileAccessFromFileU-</p><p>` `RLs(true) allows local HTML to read local ﬁle</p>|
| :- | :- | :- | :- |
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br6"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 5

||<p>contents via JavaScript. In this way, JavaScript in one</p><p>ﬁle zone (local HTML) can access the contents of other</p><p>ﬁle zones.</p><p>• The invocation of setAllowUniversalAccessFrom-</p><p>` `FileURLs(true) allows local HTML to retrieve Web</p><p>contents via JavaScript. However, JavaScript in one ﬁle</p><p>zone can also access the contents of other http zones.</p><p>` `Note that prior to Android 4.2, the above two access</p><p>permissions were enabled by default. To prevent this type of</p><p>vulnerability, developers must explicitly disable these permis-</p><p>sions.</p><p>` `3.1.3 Attack Model</p><p>` `Fig. 3a illustrates the attack model for exploiting the ﬁle-based</p><p>` `cross-zone vulnerabilities.</p><p>` `Attack vector. If the manifest XML ﬁle of an app deﬁnes a</p><p>` `component that can respond to a file:// browsing request,</p><p>then the attack vector is open. For example, in Fig. 5, since the</p><p>activity component owns an intent-ﬁlter, which deﬁnes the ac-</p><p>tion as “VIEW”, the category as “BROWSABLE” or “DEFAULT”,</p><p>` `and the data as a “file” scheme (“javascript” scheme</p><p>` `is similar), a malicious file:// browsing request can be</p><p>accepted by this intent-ﬁlter of the activity and delivered</p><p>to WebView. Note that an intent is a messaging object that</p><p>an app component uses to request an action from another</p><p>component, and an intent-ﬁlter is a data structure associated</p><p>with a component that speciﬁes the type of intents that the</p><p>component receives.</p><p>` `Attack methods. The SOP of a vulnerable app can be</p><p>compromised through the following two means:</p><p>` `• SOP is compromised from file:// to file://. For</p><p>` `example, in Fig. 6a, the malicious JavaScript code (can</p><p>` `be hidden in a local malware or a local third-party</p><p>` `HTML ﬁle) sends an asynchronous request via the</p><p>` `method XMLHttpRequest()8 to access a sensitive ﬁle</p><p>` `(text.txt) on the SD card of the user device. Subse-</p><p>` `quently, the contents of the ﬁle are displayed via the</p><p>` `JavaScript function alert().</p><p>• SOP is compromised from file:// to http://.</p><p>` `Fig. 6b shows an example that is similar to the example</p><p>` `in Fig. 6a.</p><p>` `<activity</p><p>` `<intent−ﬁlter></p><p>` `<action android:name="android.intent.action.VIEW" ></p><p>` `<category android:name="android.intent.category.</p><p>` `DEFAULT"></p><p>` `<category android:name="android.intent.category.</p><p>` `BROWSABLE"></p><p>` `<data android:scheme="file"></p><p>` `<data android:scheme="http"></p><p>` `<data android:scheme="https"></p><p>` `</intent−ﬁlter></p><p></activity></p><p>Fig. 5. An example of attack vectors.</p><p>8\. XMLHttpRequest. http://www.w3.org/TR/XMLHttpRequest</p>||<p>` `<script></p><p>` `var aim = "file:///mnt/sdcard/test.txt";</p><p>` `var xhr = new XMLHttpRequest();</p><p>` `xhr.onreadystatechange = function(){</p><p>` `if (xhr.readyState == 4){</p><p>` `alert (xhr.responseText);</p><p>` `}</p><p>` `};</p><p>` `xhr.open(’GET’,aim,true);</p><p>` `xhr.send(null);</p><p></script></p><p>(a)</p><p><script></p><p>var aim = "http://www.baidu.com";</p><p>var xhr = new XMLHttpRequest();</p><p>xhr.onreadystatechange = function() {</p><p>if (xhr.readyState == 4){</p><p>alert (xhr.responseText);</p><p>}</p><p>};</p><p>xhr.open(’GET’,aim,true);</p><p>xhr.send(null);</p><p></script></p><p>(b)</p><p>Fig. 6. Two attack methods of the ﬁle-based cross-zone</p><p>vulnerabilities.</p><p>3\.2 Remote Pattern and WebView UXSS Vulnerability</p><p>3\.2.1 Remote Pattern</p><p>Developers often use WebView to open a remote website or a</p><p>third-party JavaScript library. We refer to this type of JavaScript</p><p>usage as the remote pattern (cf. Fig. 2b).</p><p>` `Similar to the local pattern, the remote pattern can be</p><p>implemented by any of the ﬁrst three WebView APIs in Table 1.</p><p>Remote JavaScript codes can be loaded via either “http://”</p><p>or “https://”. Fig. 7 presents two examples of this pattern</p><p>using loadUrl().</p><p>myWebView.loadUrl("http://www.facebook.com/");</p><p>myWebView.loadUrl("http://code.jquery.com/jquery.js");</p><p>Fig. 7. Two examples of the remote pattern.</p><p>3\.2.2 WebView UXSS Vulnerability</p><p>The remote pattern may introduce WebView UXSS (universal</p><p>cross-site scripting [7]) vulnerabilities. UXSS is a type of client-</p><p>side loophole of browsers and browser extensions caused</p><p>by failures in validating the user input. Attackers can inject</p><p>malicious JavaScript to compromise SOP abided by browsers.</p><p>This type of vulnerability is exploitable when WebView is</p><p>navigable. When a user logs into a trusted website loaded by</p><p>WebView, sensitive data, such as user name and password,</p><p>are generally stored in cookies. Hence, these cookies could be</p><p>stolen during page navigation if malicious JavaScript code is</p><p>injected into the pages [2].</p><p>` `The Google Chrome browser based on the WebKit kernel</p><p>was reported to have UXSS vulnerabilities [8], and thus, An-</p><p>droid apps that use WebView of the WebKit kernel (prior to</p><p>Android 4.4) are infected by this type of vulnerability. Starting</p><p>with Android 4.4, WebView uses Blink, but still suffers from</p><p>UXSS vulnerabilities until Android 5.0.</p>|
| :- | :- | :- | :- |
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br7"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 6

||<p>3\.2.3 Attack Model</p><p>If a remote pattern is used in an app that exposes an attack</p><p>vector, then the WebView UXSS vulnerability can be exploited</p><p>(cf. Fig. 3b).</p><p>` `Attack vector. If the manifest XML ﬁle deﬁnes a component</p><p>that can respond to an http:// browsing request, then the</p><p>` `attack vector is open (cf. the example in Fig. 5).</p><p>` `Attack methods. There are various types of attack means,</p><p>including script label, iframe label, XMLHttpRequest API, and</p><p>so forth. Fig. 8 presents an example in which the JavaScript</p><p>code opens a webpage via an iframe and creates a button in the</p><p>main frame. Once the button is clicked, the JavaScript code can</p><p>bypass the input checking via a crafted attribute containing a</p><p>“\u0000” character and then access cookies of the page loaded</p><p>within the iframe. This is caused by the inappropriate handling</p><p>of the NULL byte (\u0000) by the url parser, where the data</p><p>after “\u0000” are not checked. This attack requires that users</p><p>have logged into the website.</p>||<p>myWebView.loadUrl("javascript:CheckUsername(’"+strName+"</p><p>` `’);");</p><p>myWebView.addJavascriptInterface(new MyJSInterface(),"JsBridge");</p><p>−−−−−−</p><p>class MyJsInterface{</p><p>void Prompt(){</p><p>//prompt users</p><p>` `}</p><p>}</p><p>(a)</p><p><script></p><p>function CheckUsername(username){</p><p>if (!username.isValid()){</p><p>JsBridge.Prompt();</p><p>}</p><p>}</p><p></script></p><p>(b)</p><p>Fig. 9. An example of the JSBridge pattern: (a) Java code of an</p><p>app, and (b) JavaScript code in webpages.</p>|
| :- | :- | :- | :- |
||<p><iframe name="test" src="http://www.abc.com/"></p><p></iframe></p><p><input type=button value="test"</p><p>onclick="window.open(’\u0000javascript:alert(document.</p><p>` `cookie)’,’test’)" ></p><p>Fig. 8. An attack method of the WebView UXSS vulnerabilities.</p><p>` `Since UXSS vulnerabilities occur in the WebView itself,</p><p>attackers can run malicious JavaScript code in any page loaded</p><p>by the vulnerable WebViewto steal sensitive page contents,</p><p>cookies, session tokens, and so forth. Stolen cookies may lead</p><p>to serious attacks, such as session hijacking and user imperson-</p><p>ating. Cross-site scripts can even rewrite the contents of HTML</p><p>pages.</p>||<p>3\.3.2 JS-to-Java Interface Vulnerability</p><p>The JSBridge pattern exposes a native JS-to-Java interface to the</p><p>JavaScript environment, and it may suffer from JS-to-Java in-</p><p>terface vulnerabilities if appropriate security countermeasures</p><p>are not taken.</p><p>` `The interface name can easily be found via keyword search-</p><p>ing in the decompiled app. Accordingly, malicious JavaScript</p><p>code can call the method getClass() of the interface via the</p><p>provided name and then abuse the Java reﬂection mechanism</p><p>to obtain any other Java objects to invoke their methods. Al-</p><p>though Google has deployed several security countermeasures</p><p>in recent Android versions, the JS-to-Java interface vulnerabil-</p><p>ities still exist in real-world apps:</p>|
||<p>3\.3 JSBridge Pattern and JS-to-Java Vulnerability</p><p>3\.3.1 JSBridge pattern</p><p>As mentioned in Section 2.2.3, Android provides a mechanism</p><p>for apps to support the JavaScript-Java interaction. We refer</p><p>to the JavaScript usage in this case as the interface pattern</p><p>(cf. Fig. 2c).</p><p>` `In contrast to the ﬁrst two patterns, the JSBridge</p><p>pattern builds a bridge between apps and webpages.</p><p>Through this bridge, apps can have control over Web</p><p>contents via JavaScript. JavaScript code in webpages can</p><p>also call the Java code. To use the JSBridge pattern,</p><p>the method addJavascriptInterface(Object object,</p><p>String name) is invoked to inject a Java object as a global</p><p>variable into the JavaScript environment. Thus, JavaScript code</p><p>executed in WebView can call all public methods of the Java</p><p>object via the provided name.</p><p>` `Fig. 9 shows an example that uses this pattern to achieve</p><p>a form validation. The Java code in Fig. 9a creates a JS-to-Java</p><p>interface object JsBridge and attaches it to the WebView. When</p><p>WebView receives a form validation request from the user,</p><p>it uses the method loadUrl() to call a JavaScript function</p><p>CheckUserName() (cf. Fig. 9b). If the user name is invalid, the</p><p>JavaScript function then invokes the Java method Prompt()</p><p>through the JsBridge interface to prompt the user to enter a</p><p>` `valid user name.</p>||<p>1) Google requires that accessible methods of JS-to-Java in-</p><p>` `terfaces must be explicitly annotated with @JavascriptIn-</p><p>` `terface after Android 4.2. Since the Java reﬂection method</p><p>` `getClass() is not annotated, reﬂection-based attacks</p><p>` `can be reduced. However, this countermeasure only pro-</p><p>` `tects apps on Android 4.2 or later versions.</p><p>2) Google provides WebView with a method</p><p>` `removeJavascriptInterface(String name) in</p><p>` `all Android versions to remove previously injected</p><p>` `system-generated interfaces. However, this method is</p><p>` `rarely used to remove app-deﬁned interfaces in practice.</p><p>3) Google no longer allows the Java reﬂection method</p><p>` `getClass() to be invoked via JS-to-Java interfaces after</p><p>` `Android 6.0. However, it takes time for the new versions</p><p>` `to spread, and many apps have backward compatibility</p><p>` `with the older Android versions, which are still popular</p><p>` `on user devices. According to Google9, as of July 2017, ap-</p><p>` `proximately 60% of Android devices are running versions</p><p>` `prior to 6.0.</p><p>3\.3.3 Attack Model</p><p>If the JSBridge pattern is used in an app that exposes an attack</p><p>vector, then hackers can easily attack the app via injected</p><p>malicious JavaScript code (cf. Fig. 3c).</p><p>9\. https://developer.android.com/about/dashboards/index.html</p>|
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br8"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 7

||<p>myWebView.addJavascriptInterface(new JSInterface(),"JsAttack");</p><p>(a)</p><p><script></p><p>function execute(){</p><p>return JsAttack.getClass() .forName("android.telephony.</p><p>SmsManager")</p><p>.getMethod("getDefault",null).invoke(null,null).sendTextMessage();</p><p>}</p><p></script></p><p>(b)</p><p><script></p><p>function execute(cmdArgs){</p><p>return JsAttack.getClass() .forName("java.lang.Runtime").</p><p>getMethod("getRuntime",null)</p><p>.invoke(null,null) .exec(cmdArgs);</p><p>}</p><p>function exec(){</p><p>execute(["/system/bin/sh","-c","echo -n Attacks by JS</p><p>>> /mnt/sdcard/file.txt"]);</p><p>}</p><p></script></p><p>(c)</p><p>Fig. 10. Two attack examples of JS-to-Java interface</p><p>vulnerabilities: (a) Java code of an app, (b) one attack example,</p><p>and (c) another attack example.</p><p>Attack vector. If the manifest XML ﬁle deﬁnes a component</p><p>responsible for a or browsing request, then file:// http://</p><p>the attack vector is open (cf. the example in Fig. 5).</p><p>Attack methods. Fig. 10 presents two attack examples of</p><p>when an app exposes a JS-to-Java interface named JsAttack</p><p>(cf. Fig. 10a):</p>||<p>` `Finding 1: Among the top-100 apps, 89 enable JavaScript</p><p>execution. JavaScript is mainly used in four scenarios.</p><p>Approximately 1/3 of the usage is attributed to third-party</p><p>libraries.</p><p>Implications: JavaScript is widely used in Android</p><p>apps. Third-party libraries occupy a large proportion of</p><p>JavaScript usage.</p><p>` `According to our empirical study, JavaScript is mainly</p><p>used in the following scenarios:</p><p>1) An app uses JavaScript to validate form elements before</p><p>` `they are submitted to the server. For example, Dropbox</p><p>` `uses JavaScript to check the strength of a password by</p><p>` `client-side JavaScript.</p><p>2) Webpages leverage JavaScript to interact with users\. For</p><p>` `example, Facebook uses WebView to display webpages that</p><p>` `use JavaScript for user interaction.</p><p>3) JavaScript manipulates the elements of HTML pages\. For</p><p>` `example, Gmail uses JavaScript to format messages.</p><p>4) Third-party libraries require JavaScript support\. For ex-</p><p>` `ample, in addition to loading advertisements, the app</p><p>` `Subway Surfers employs the Flurry framework, which uses</p><p>` `JavaScript for data statistics.</p><p>TABLE 4</p><p>Statistics of JavaScript Usage Patterns and Potential</p><p>Vulnerabilities in the Top-100 Apps</p><p>` `Potential</p><p>Pattern Total Core Lib</p><p>` `Total Core Lib</p><p>vulnerability</p><p>Local 73 49 24 File-based 56 37 19</p><p>Remote 81 51 30 UXSS 79 52 27</p><p>Interface 72 50 22 JS-to-Java 69 51 18</p><p>Callback 63 43 20 - - - -</p>|
| :- | :- | :- | :- |
||<p>• In Fig. 10b, the JavaScript code invokes the method</p><p>` `getClass() of JsAttack, and it uses the Java reﬂection</p><p>` `mechanism to obtain the Android SmsManager object.</p><p>` `Then, the method SendTextMessage() of SmsMan-</p><p>ager is called to send a message. This attack would</p><p>be successful if the app has permission to send SMS</p><p>messages.</p><p>• In Fig. 10c, the JavaScript code uses a similar approach</p><p>` `to obtain the Java Runtime object to execute any shell</p><p>commands. The command in this example writes the</p><p>text “Attacks by JS” into a ﬁle on the SD card. The</p><p>` `attack would be successful if the app has the “write”</p><p>` `permission to external storage.</p><p>` `Since malicious JavaScript code can use Java reﬂection to</p><p>access the resources of both apps and user devices, these</p><p>vulnerabilities can lead to data leaks. Although the attacks</p><p>are restricted by permissions owned by the vulnerable apps,</p><p>it is possible for attackers to run a root exploit for more</p><p>permissions. More seriously, attackers may even exploit this</p><p>type of vulnerability to install backdoors on user devices [9].</p><p>4 CHARACTERIZING JAVASCRIPT USAGE AND VUL-</p><p>` `NERABILITIES IN THE TOP-100 APPS</p><p>4\.1 Usage of JavaScript</p><p>In this subsection, we report on the JavaScript</p><p>usage in the top-100 Android apps:</p>||<p>TABLE 5</p><p>The Number of Apps in Which Each JavaScript Usage Pattern is</p><p>` `Employed in Each Third-party Library</p><p>` `Ptn. Local Remote Interface Callback</p><p>Lib</p><p>` `Jirbo 13 11 2 12</p><p>` `Mopub 9 11 3 0</p><p>` `Vungle 8 6 0 0</p><p>` `Flurry 6 4 1 0</p><p>Chartboost 6 3 0 0</p><p>` `Tapjoy 5 4 7 5</p><p>` `Millennial 4 3 2 3</p><p>` `Appboy 3 3 0 0</p><p>` `InMobi 1 7 7 5</p><p>` `Mraid 2 2 2 3</p><p>` `As summarized in Table 4, nearly 2/3 of the JavaScript</p><p>usage is due to the core functionality of the apps themselves.</p><p>The remaining 1/3 is caused by third-party libraries, such as</p><p>frameworks, advertisements, and so forth. Frameworks facil-</p><p>itate the use of some integrated functions, which accelerates</p><p>app development. Although advertisements increase the rev-</p><p>enue for the app authors, these third-party libraries may also</p><p>introduce JavaScript-related vulnerabilities. Moreover, many</p><p>libraries are rarely or slowly updated [10] but are constantly</p><p>used in new versions of apps, which increases the exposure</p><p>to vulnerabilities. To this end, we also study the JavaScript</p><p>usage patterns and vulnerabilities in 10 of the most popular</p><p>third-party libraries used in these apps. Table 5 and Table 6</p>|
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br9"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 8

TABLE 7

JavaScript Usage Patterns and Vulnerabilities in the Top-100 Apps

` `Pattern Potential vulnerability Attack vectors Victims
Name Total Name No Yes Closed Open

` `Local 73 File-based 17 56 49 7 7
 Remote 81 UXSS 2 79 39 40 40
Interface 72 JS-to-Java 3 69 34 35 35
 Callback 63 - - - - - -

||<p>TABLE 6</p><p>The Number of Apps in Which Each Type of Potential JavaScript</p><p>` `Vulnerability is due to Each Third-party Library</p><p>` `Vulner. File-based UXSS JS-to-Java</p><p>Lib</p><p>` `Jirbo 12 11 2</p><p>` `Mopub 6 11 3</p><p>` `Vungle 5 6 0</p><p>` `Flurry 0 4 1</p><p>Chartboost 5 3 0</p><p>` `Tapjoy 5 4 7</p><p>` `Millennial 3 3 2</p><p>` `Appboy 2 3 0</p><p>` `InMobi 0 7 7</p><p>` `Mraid 1 2 2</p>||<p>Finding 4: The JSBridge pattern is used by 72 (80.90%)</p><p>apps. For each app, the pattern appears 1 to 28 times,</p><p>with two as the median. Among these 72 apps, 22 (30.56%)</p><p>employ third-party libraries.</p><p>Implications: The JSBridge pattern is widely used in apps</p><p>due to its powerful functionality to implement the interac-</p><p>tion between webpages and apps. The usage frequency of</p><p>the JSBridge pattern in an app is relatively low.</p>|
| :- | :- | :- | :- |

||<p>100</p><p>` `80</p>||97||<p>Min</p><p>` `Max</p><p>` `Mean</p>|
| :- | :- | :- | :- | :- | :- |

|||||
| :- | :- | :- | :- |
` `63
60

||<p>` `summarize the results. Overall, all these libraries use the local</p><p>and remote patterns frequently, most of them use the JSBridge</p><p>pattern, and half of them use the callback pattern. Moreover,</p><p>all of them suffer from at least two types of vulnerabilities.</p>||<p>40</p><p>20</p>||13||23||28||15|
| :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :- |
6
 3

` `1 1 1 1
0

Local Remote Interface Callback

||<p>4\.2 Pattern Usage and Vulnerabilities</p><p>Table 7 summarizes the results of our empirical study of the</p><p>top-100 apps with respect to JavaScript usage patterns, poten-</p><p>tial vulnerabilities and attacks. Fig. 11 illustrates the minimum,</p><p>maximum, and mean occurrences of each pattern in an app.</p><p>Note that the results here are based on our manual inspection.</p><p>More details are described in the following.</p>||<p>**Patterns**</p><p>Fig. 11. Occurrences of each pattern in an app.</p><p>4\.2.2 Exposure to Each Vulnerability</p><p>In this part, we report on the app vulnerabilities related to</p><p>JavaScript usage.</p>|
| :- | :- | :- | :- |
||<p>4\.2.1 Usage of Each Pattern</p><p>In this part, we report on the usage of each pattern in all 89</p><p>JavaScript-enabled apps.</p><p>` `Finding 2: The local pattern is used by 73 (82.02%) apps.</p><p>For each app, the pattern appears 1 to 63 times, with 13 and</p><p>14 times as the medians. Among these 73 apps, 24 (32.88%)</p><p>employ third-party libraries.</p><p>` `Implications: The local pattern is used both widely and</p><p>frequently in apps.</p><p>Finding 3: The remote pattern is used by 81 (91.01%) apps.</p><p>For each app, the pattern appears 1 to 97 times, with</p><p>17 times as the median. Among these 81 apps, 30 (37%)</p><p>employ third-party libraries.</p><p>Implications: The remote pattern is the most commonly</p><p>used pattern in apps. It is also the most frequently used</p><p>pattern in an app.</p>||<p>Finding 5: Among all 73 apps using the local pattern, 56</p><p>(76.7%) set inappropriate control of JavaScript access to</p><p>zones, and only 7 (12.5%) of these 56 expose the attack</p><p>vectors. Among the 56 apps, 19 (33.9%) employ at least one</p><p>third-party library.</p><p>Implications: When the local pattern is used, JavaScript</p><p>access to zones is often allowed, but the attack vector is</p><p>closed by most apps. Only less than 10% are exploitable.</p><p>Moreover, approximately 1/3 of ﬁle-based cross-zone vul-</p><p>nerabilities are attributed to third-party libraries.</p><p>Finding 6: Among all 81 apps using the remote pattern,</p><p>79 (97.5%) apps can navigate webpages within WebView.</p><p>Among the 79 apps, 40 (50.6%) expose the attack vectors,</p><p>and 27 (34.18%) employ at least one third-party library.</p><p>Implications: When the remote pattern is used, WebView</p><p>is always navigable, and the attack vector is often exposed.</p><p>This indicates that most developers are unaware of this</p><p>type of vulnerability. Moreover, approximately 1/3 of We-</p><p>bView UXSS vulnerabilities are due to third-party libraries.</p>|
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br10"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 9

||<p>Finding 7: Among all 72 apps using the JSBridge pattern, 69</p><p>(95.8%) expose JS-to-Java interfaces. Among the 69 apps, 35</p><p>(50.7%) expose the attack vectors, and 18 (26.09%) employ</p><p>at least one third-party library.</p><p>Implications: When the JSBridge pattern is used, JS-to-</p><p>Java interfaces are often exposed. This indicates that the</p><p>majority of developers fail to implement security coun-</p><p>termeasures when using the JSBridge pattern. Moreover,</p><p>approximately 1/3 of JS-to-Java interface vulnerabilities are</p><p>caused by third-party libraries.</p><p>5 EVALUATION ON 1,000 REAL-WORLD APPS</p><p>` `To extensively study JavaScript-related vulnerabilities in the</p><p>` `Android market, we developed a static analysis tool called</p><p>` `JSDroid and have applied it on 1,000 large real-world Android</p><p>` `apps to automatically detect their potential JavaScript-related</p><p>` `vulnerabilities and to study the performance of our tool. These</p><p>` `1,000 apps are randomly selected from the Android market,</p><p>` `each with at least 50,000 downloads (per speciﬁc version</p><p>` `counted by APK4Fun: <https://www.apk4fun.com/>) and 350K</p><p>` `lines of code and 9.7M Dex ﬁle on average. We downloaded</p><p>` `their most recent version as of August 2016 from APK4Fun.</p><p>` `In this section, we ﬁrst present the design and implemen-</p><p>` `tation of JSDroid followed by our experimental results. All</p><p>experiments are performed on a computer with an Intel Core</p><p>i7 3.6 GHz CPU with 16 GB of memory and running Windows</p><p>7 and JDK 1.7.</p><p>5\.1 The JSDroid Tool</p><p>` `We design JSDroid based on the characteristics of JavaScript</p><p>` `usage patterns and vulnerabilities described in Section 3 and</p><p>` `implement it based on Soot [11]10 and AXMLPrinter11. Fig. 12</p><p>depicts the architecture of JSDroid. The input is a list of APK</p><p>` `ﬁles, and the output is a report that records the detected</p><p>` `patterns and vulnerabilities. For each app, JSDroid performs</p><p>` `a linear scan of the code and resources with the following six</p><p>` `modules:</p><p>` `Code Parser: In an Android APK, there is a code ﬁle</p><p>in DEX (Dalvik Executable) format. Since DEX is a binary</p><p>encoded ﬁle, it is difﬁcult to apply program analysis on it.</p><p>To this end, the code parser converts the Dalvik bytecode to</p><p>Jimple (Soot’s principal intermediate representation) [12] ﬁles</p><p>with the help of Soot. Jimple has a clear code structure that</p><p>facilitates the static analysis.</p><p>` `XML Parser: The manifest XML ﬁle of an Android APK</p><p>is difﬁcult to read because Android developers often use code</p><p>obfuscation techniques to protect their apps. The XML parser</p><p>converts the obfuscated manifest XML ﬁle to an easy-to-read</p><p>XML ﬁle with the help of AXMLPrinter.</p><p>` `JavaScript Usage Analyzer: Jimple summarizes 15 types</p><p>of Java statements, such as AssignStmt, InvokeStmt, IfStmt,</p><p>and so forth. The JavaScript usage analyzer scans all Jim-</p><p>ple ﬁles. If it ﬁnds one InvokeStmt that invokes the method</p><p>setJavaScriptEnabled() of WebSettings with the operand</p><p>` `“1” (Java boolean value true), then the app uses JavaScript.</p><p>` `10. Soot-GitHub. http://github.com/Sable/soot</p><p>` `11. AXMLPrinter. http://code.google.com/archive/p/android4me-/</p><p>downloads</p>||<p>` `Pattern Analyzer: The pattern analyzer scans all Jimple</p><p>` `ﬁles to ﬁnd InvokeStmts that invoke APIs related to each of</p><p>the four JavaScript usage patterns. A challenge in this module</p><p>is to differentiate the local pattern and the remote pattern</p><p>because they both use the same WebView APIs (loadUrl(),</p><p>loadData(), and loadDataWithBaseURL()) but with dif-</p><p>ferent parameter values. To address this problem, we analyze</p><p>the value of the string URLs passed to each API in the follow-</p><p>ing four ways:</p><p>1) If the URL is a constant string and the string preﬁx is</p><p>` `“file:///”, “javascript:” or “<script>”, then we</p><p>` `classify it as the local pattern; otherwise, we classify it</p><p>` `as the remote pattern (the preﬁx could be “http://” or</p><p>` `“https://”).</p><p>2) If the string URL is a static class member, then we analyze</p><p>` `its deﬁnition in the class and classify it by following (1).</p><p>3) If the URL is a local variable of StringBuffer or String-</p><p>` `Builder, then we construct a UnitGraph (control ﬂow graph</p><p>` `implemented in Soot) for the current method and con-</p><p>` `duct data-ﬂow analysis. If a constant string ﬂows to the</p><p>` `variable, we follow (1) to classify the pattern. In this</p><p>` `case, we also analyze popular StringBuffer/StringBuilder</p><p>` `functions such as toString(), append() and init()</p><p>` `and process them according to their semantics.</p><p>4) If the URL is a variable passed from the method parameter</p><p>` `or returned from a method call, then we use the call</p><p>` `graph to ﬁnd the corresponding caller or callee methods</p><p>` `and again analyze the values in those methods. The call</p><p>` `graph is constructed based on the soot-infoﬂow-android</p><p>` `framework as a part of FlowDroid [13].</p><p>` `Vulnerability Analyzer: After a pattern is identiﬁed, the</p><p>vulnerability analyzer determines whether the speciﬁc use of</p><p>this pattern leads to the related vulnerability according to the</p><p>precondition of each type of vulnerability (cf. Section 3):</p><p>1) Detection of ﬁle-based cross-zone vulnerabilities in local</p><p>` `pattern. We traverse all statements in the current</p><p>` `method (which contains an InvokeStmt comprising</p><p>` `the local pattern) and in the current class. If there</p><p>` `are three InvokeStmts that respectively invoke the</p><p>` `three WebSettings APIs (setAllowFileAccess(),</p><p>` `setAllowFileAccessFromFileURLs(), and</p><p>` `setAllowUniversalAccessFromFileURLs()) and if</p><p>` `the values of their parameters are all false (indicating that</p><p>` `cross-zone access is strictly forbidden), then we classify</p><p>` `that the app does not suffer from ﬁle-based cross-zone</p><p>` `vulnerabilities; otherwise, it may suffer from this type of</p><p>` `vulnerability.</p><p>` `2) Detection of WebView UXSS vulnerabilities in remote pattern.</p><p>` `We traverse all statements in the current WebView class</p><p>` `and determine its navigability by the following rules. If</p><p>` `the WebView does not have a WebViewClient, then it is</p><p>` `non-navigable. Otherwise, we continue to analyze each</p><p>` `subclass of the WebViewClient. If the subclass does not</p><p>` `overwrite the method shouldOverrideUrlLoading(),</p><p>` `or in the overwritten method, it overloads a new URL or</p><p>` `returns false, then the current WebView is navigable. If</p><p>` `the WebView is navigable, then the app may suffer from</p><p>` `WebView UXSS vulnerabilities; otherwise, it does not.</p><p>3) Detection of JS-to-Java interface vulnerabilities in JSBridge pat-</p><p>` `tern. Our analysis has two steps. First, we check whether</p>|
| :- | :- | :- | :- |
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br11"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 10

||<p>**Dex**</p><p>**code**</p>||<p>**Code**</p><p>**Parser**</p>||<p>**Jimple**</p><p>` `**File**</p>||<p>**JavaScript**</p><p>` `**Analyzer**</p>||<p>**Pattern**</p><p>**Analyzer**</p>||<p>**Vulnerability**</p><p>` `**Analyzer**</p>|
| :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :- | :- |
**APK**

||<p>**XML**</p><p>**Parser**</p>||<p>**Manifest**</p><p>**XML File**</p>||<p>**Attack Entrance**</p><p>` `**Analyzer**</p>||<p>**Detection**</p><p>` `**Report**</p>|
| :- | :- | :- | :- | :- | :- | :- | :- |
Fig. 12. Overall architecture of JSDroid.

TABLE 8

Experimental Results on 1,000 Large Real-world Apps

Total Use JS Pattern Potential vulnerability Attack vector Victim
 Name No Name No Closed Open

Local 796 File-based 702 628 74 74

` `Remote 762 UXSS 708 516 192 192
1,000 806

Interface 618 JS-to-Java 600 415 185 185

Callback 393 - - - - -

TABLE 9 Effectiveness Evaluation of JSDroid

App name Data origin Pattern times Vulner. numbers Criteria
 P1 P2 P3 P4 V1 V2 V3 TP FP FN precision recall

Opera Mini Empirical study 38 13 7 0 0 0 5 61 1 2 98.4% 96.8%

JSDroid 39 11 7 0 0 0 5

ES File Explorer Empirical study 31 38 8 3 31 14 7 128 2 4 98.5% 97.0%

JSDroid 32 34 8 4 32 14 7

Line Empirical study 12 13 1 4 0 11 1 42 0 0 100% 100%

JSDroid 12 13 1 4 0 11 1

Tango Empirical study 13 20 4 3 13 4 3 59 2 2 96.7% 96.7%

JSDroid 14 18 4 3 14 4 3

Viber Empirical study 10 12 2 4 0 1 2 31 0 0 100% 100%

JSDroid 10 12 2 4 0 1 2

Dropbox Empirical study 14 9 6 1 14 2 6 51 1 1 98.1% 98.1%

JSDroid 14 8 6 2 14 2 6

Go Launcher EX Empirical study 21 19 7 0 21 4 5 77 0 0 100% 100%

JSDroid 21 19 7 0 21 4 5

Google TTS Empirical study 4 6 0 2 4 1 0 17 1 0 94.4% 100%

JSDroid 4 6 0 3 4 1 0

Pics Art Photo Empirical study 17 25 7 3 0 4 5 61 4 0 93.8% 100%

JSDroid 18 25 7 4 0 6 5

Chat On Empirical study 13 27 2 0 13 4 3 61 1 1 98.4% 98.4%

JSDroid 13 28 1 0 13 4 3

Average - - - - - - - - - - - 97.8% 98.7%

||<p>` `the app limits the usage of the JSBridge pattern to Android</p><p>` `4.2 or later versions. Second, we check whether the app re-</p><p>` `moves a previously used JS-to-Java interface (i.e., injected</p><p>` `Java object from a WebView). If both of these conditions</p><p>` `are false, then the app may suffer from JS-to-Java interface</p><p>` `vulnerabilities. For the ﬁrst condition, we perform a dom-</p><p>` `inator analysis on the current InvokeStmt (which satisﬁes</p><p>` `the JSBridge pattern) and check whether it is dominated</p><p>` `by an IfStmt with the condition “Build.VERSIONS.SDK -</p><p>` `INT >= 17” (here, 17 corresponds to the version number</p><p>` `of Android 4.2). We ﬁrst identify whether such an IfStmt</p><p>exists; if yes, we then check whether the IfStmt domi-</p><p>nates the current InvokeStmt or the method containing</p><p>it. For the second condition, we traverse all methods in</p><p>the current class and check whether the WebView API</p><p>removeJavascriptInterface() is invoked. If yes, we</p><p>remove that interface from the maintained list of JSBridge</p><p>patterns identiﬁed in the app. After all JSBridge patterns</p><p>are analyzed, if the list is empty, then the app does not</p>||<p>have JS-to-Java interface vulnerabilities.</p><p>` `Attack Vector Analyzer: After one vulnerability is iden-</p><p>` `tiﬁed, the attack vector analyzer checks whether the app</p><p>` `exposes an attack vector by tracking the manifest XML ﬁle.</p><p>` `This module scans the manifest ﬁle from outer labels to inner</p><p>` `labels iteratively to ﬁnd a file:// browsing entrance or an</p><p>` `http:// browsing entrance. For instance, if it ﬁnds one intent-</p><p>` `ﬁlter label that owns the action label “VIEW”, the category label</p><p>` `“BROWSABLE” or “DEFAULT”, and the data label “file”, then</p><p>the app exposes a file:// browsing entrance.</p><p>5\.2 Experimental Results</p><p>Table 8 summarizes the experimental results of the 1,000 large</p><p>real-world Android apps based on JSDroid.</p><p>` `JavaScript usage. JavaScript is prevalently used in these</p><p>1,000 apps as 806 of them enable JavaScript execution. The</p><p>local pattern is used by 796 apps, the remote pattern is used by</p><p>762 apps, and the JSBridge pattern is used by 618 apps.</p>|
| :- | :- | :- | :- |
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br12"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 11

||<p>` `Vulnerability exposure. In total, JSDroid ﬁnds that 201</p><p>of the 1,000 apps involve exploitable JavaScript-related vul-</p><p>nerabilities (i.e., the attack vectors are open), with a total of</p><p>451 exploitable vulnerabilities (many apps have more than</p><p>one type of vulnerability). Among the 796 apps using the</p><p>local pattern, 702 apps set inappropriate control of JavaScript</p><p>access to zones, and thus, these apps have potential ﬁle-based</p><p>cross-zone vulnerabilities. JSDroid reports that 74 of these apps</p><p>` `open the attack vectors and can thus be attacked. Among the</p><p>` `762 apps using the remote pattern, 708 apps set WebView as</p><p>` `navigable and are potentially vulnerable to WebView UXSS</p><p>` `vulnerabilities. JSDroid ﬁnds that 192 of the apps expose</p><p>` `the attack vectors, which can be attacked. Among the 618</p><p>` `apps using the JSBridge pattern, 600 apps expose JavaScript</p><p>` `interfaces in versions prior to Android 4.2 and thus suffer from</p><p>` `potential JS-to-Java interface vulnerabilities. JSDroid ﬁnds that</p><p>` `185 of them open the attack vectors and can thus be attacked.</p><p>5\.2.1 Performance of JSDroid</p><p>In this subsection, we report the performance of our tool</p><p>JSDroid in terms of effectiveness and efﬁciency.</p><p>` `We apply JSDroid to the top-100 apps and compare the</p><p>results with the manual results obtained by our empirical</p><p>study on these apps. Table 9 summarizes the experimental</p><p>results on 10 apps randomly selected from the top-100 apps.</p><p>P1, P2, P3, and P4 represent local pattern, remote pattern,</p><p>JSBridge pattern, and callback pattern, and V1, V2, and V3</p><p>represent ﬁle-based cross-zone vulnerabilities, WebView UXSS</p><p>vulnerabilities, and JS-to-Java interface vulnerabilities, respec-</p><p>tively. We list the number of patterns and vulnerabilities</p><p>identiﬁed by JSDroid and our empirical study. The results</p><p>of our empirical study are used as the ground truth, which</p><p>was established by the authors of this paper. In fact, since the</p><p>conditions to determine whether an app involves JavaScript-</p><p>related vulnerabilities is clear, the validity of the manual check</p><p>is not a severe problem.</p><p>` `Overall, JSDroid generates very few false positives/neg-</p><p>atives in identifying JavaScript usage patterns and vulnera-</p><p>bilities, and the average precision and recall are 97.8% and</p><p>98\.7%, respectively. The high precision and recall give credit to</p><p>Soot and the problem we study. With Soot, JSDroid transforms</p><p>` `the APK ﬁles into Jimple code and then scans the Jimple code</p><p>` `to check how the apps use JavaScript, whether vulnerabilities</p><p>` `exist, and whether the attack vectors are open. Since the major</p><p>` `task of the scanning is to search relevant APIs in the Jimple</p><p>` `code and the arguments of the APIs are not complex, the</p><p>` `accuracy of JSDroid is guaranteed. One reason for the false</p><p>` `positive/negative is that in our empirical study, we employ</p><p>` `Dex2Jar to decompile APK ﬁles into readable pure-text Java</p><p>` `source code, whereas JSDroid uses Soot to decompile APK</p><p>` `ﬁles into code-structured Jimple ﬁles. The code of some apps</p><p>` `obtained by these two different tools (i.e., Dex2Jar and Soot)</p><p>are not completely consistent, which results in the deviation of</p><p>the results returned by JSDroid.</p><p>` `For time efﬁciency, JSDroid completes a batch of vulner-</p><p>ability detection on 100 apps in less than 20 minutes. In other</p><p>words, JSDroid needs only 12 seconds on average to analyze a</p><p>complex app.</p>||<p>TABLE 10</p><p>Experimental Comparison between JSDroid and FileCross</p><p>Package name FileCross JSDroid</p><p>V1 V1 V2 V3</p><p>` `com.airwatch.browser ~~× × √ √~~</p><p>com.apps4mm.browserformm ~~√ √ √ ×~~</p><p>` `com.bluecoat.k9.android ~~× √ √ ×~~</p><p>` `com.browser.sogood.ui ~~× × √ ×~~</p><p>` `com.candy.browser ~~× × √ √~~</p><p>` `com.cloudmosa.pufﬁnFree ~~× × √ √~~</p><p>` `com.compal.android.browser ~~√ √ √ ×~~</p><p>com.crowbar.beaverlite ~~× × × √~~</p><p>` `com.ddm.netviewer ~~√ √ √ √~~</p><p>com.droidboosters.tigerbrowser ~~× √ √ ×~~</p><p>` `com.lpedroid.internet ~~× × × ×~~</p><p>` `com.mahoni.browser ~~× × × ×~~</p><p>` `com.MobileWebSite.v1 ~~× × √ ×~~</p><p>com.mx.browser.appendix ~~× × √ √~~</p><p>` `com.ninesky.browser ~~√ √ √ √~~</p><p>` `com.opera.mini.android ~~× × √ √~~</p><p>` `com.ploxpex.browserexample ~~× × × ×~~</p><p>` `com.soshall.apps.browser ~~√ √ × ×~~</p><p>` `com.unibera.privatebrowser ~~× × × ×~~</p><p>` `com.websearch.browser ~~√ √ √ ×~~</p><p>` `com.whattheapps.fbrowsers ~~× × × ×~~</p><p>com.wSuperFastInternetBrowser × × × ×</p><p>` `harley.browsers √ √ ~~× ×~~</p><p>iron.web.jalepano.browser ~~√ √ √ √~~</p><p>` `it.nikodroid.ofﬂine ~~× × × ×~~</p><p>` `jp.ddo.pigsty.HabitBrowser ~~× √ √ ×~~</p><p>` `me.android.browser ~~× × × ×~~</p><p>mobi.mgeek.TunnyBrowser ~~× √ √ √~~</p><p>` `net.caffeinelab.pbb ~~× × × ×~~</p><p>steffen.basicbrowserfree ~~√ √ √ √~~</p><p>5\.2.2 Comparison to Existing Tools</p><p>Although several studies on JavaScript-related vulnerabilities</p><p>in Android apps exist [4], [2], [3], there is no available tool that</p><p>we can directly compare with. Chin and Wagner [3] claim that</p><p>they built a tool for detecting JS-to-Java interface vulnerabili-</p><p>ties, but neither the tool nor the experimental results based on</p><p>the tool are available. Wu et al. [4] designed a system (called</p><p>FileCross) for detecting ﬁle-based cross-zone vulnerabilities.</p><p>Although the tool is unavailable, the detailed experimental</p><p>results on 30 Android apps are publicly available. We hence</p><p>apply JSDroid to the same set of 30 apps to compare it with</p><p>` `FileCross. All APK ﬁles of these apps are downloaded from</p><p>` `the links provided in their paper.</p><p>` `Table 10 summarizes the results, where V1, V2, and V3</p><p>represent ﬁle-based cross-zone vulnerabilities, WebView UXSS</p><p>vulnerabilities, and JS-to-Java interface vulnerabilities, respec-</p><p>tively. A tick (√) in the table indicates that a tool detects a</p><p>certain type of vulnerability in an app; a cross (×) indicates</p><p>that a tool does not ﬁnd the existence of a certain type of</p><p>vulnerability. Speciﬁcally,</p><p>1) FileCross can only detect ﬁle-based cross-zone vulnerabil-</p><p>` `ities in an app, whereas JSDroid can detect all three types</p><p>` `of JavaScript-related vulnerabilities.</p><p>2) All ﬁle-based cross-zone vulnerabilities identiﬁed by</p><p>` `FileCross can also be detected by JSDroid, whereas</p><p>` `FileCross fails to ﬁnd this type of vulnerability</p><p>` `in some apps. For instance, JSDroid identiﬁes ﬁle-</p><p>` `based cross-zone vulnerabilities in four apps whose</p><p>` `package names are com.bluecoat.k9.android,</p><p>` `com.droidboosters.tigerbrowser,</p><p>jp.ddo.pigsty. HabitBrowser, and</p>|
| :- | :- | :- | :- |
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br13"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 12

TABLE 11

Results of Vulnerability Exploitation in 30 Real-World Apps

App File-based cross-zone vulner. WebView UXSS vulner. JS-to-Java interface vulner.
 Attack? 4.1.3 4.3.1 5.0 Attack? 4.1.3 4.3.1 5.0 Attack? 4.1.3 4.3.1 5.0

` `Amazon Kindle Yes ~~√ √ √~~ No - - - No - - -
 Sogou Explorer Yes ~~√ √ √~~ No - - - No - - -
Microsoft Ofﬁce Yes ~~√ √ √~~ No - - - No - - -

` `Firefox Yes ~~√ √ √~~ Yes ~~√ √ ×~~ No - - -
 Facebook No - - - Yes ~~√ √ ×~~ No - - -
 Wechat No - - - Yes ~~√ √ ×~~ No - - -
 QQ Browser No - - - Yes ~~√ √ ×~~ No - - -
 Instagram No - - - Yes ~~√ √ ×~~ No - - -
 Sina Viber No - - - Yes ~~√ √ ×~~ No - - -
 Dropbox No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Line No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Shazam No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Viber No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Pics Art Photo No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Kik No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Opera Mini No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Sohu News No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 UC Browser No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Amap No - - - Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 eBay No - - - No - - - Yes ~~√ × ×~~
 Adobe Reader No - - - No - - - Yes ~~√ × ×~~
 Baidu HD No - - - No - - - Yes ~~√ × ×~~
 Snow Ball No - - - No - - - Yes ~~√ × ×~~
 Sogou Input No - - - No - - - Yes ~~√ × ×~~
 Apc Browser Yes ~~√ √ √~~ Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Boat Browser Yes ~~√ √ √~~ Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 Es File Explorer Yes ~~√ √ √~~ Yes ~~√ √ ×~~ Yes ~~√ × ×~~
Hao123 Browser Yes ~~√ √ √~~ Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 MX Player Yes ~~√ √ √~~ Yes ~~√ √ ×~~ Yes ~~√ × ×~~
 MX Browser Yes ~~√ √ √~~ Yes ~~√ √~~ × Yes ~~√~~ × ×

mobi.mgeek.TunnyBrowser, respectively, while
 FileCross fails to do this. We successfully conduct
 real attacks on these four apps, which conﬁrms these
 vulnerabilities.

\3) Moreover, FileCross can only detect ﬁle-based cross-zone
 vulnerabilities in Android browsers, whereas JSDroid is
 applicable to all types of Android apps\.

6 EXPLOITING VULNERABILITIES IN REAL APPS

||<p>For vulnerable apps with attack vectors, we are able to conduct</p><p>real attacks by exploiting the vulnerabilities. In this section,</p><p>we present our results of vulnerability exploitation in 30 real-</p><p>world apps (15 from the top-100 apps and 15 from the 1,000</p><p>large apps). All 451 of the vulnerabilities identiﬁed by JSDroid</p><p>are exploitable. Due to time and resource limitations, we only</p><p>inspected the exploitable vulnerabilities in 30 apps.</p><p>` `Table 11 summarizes our attack results on these 30 apps.</p><p>For each app, we list our attack results for the three types of</p><p>JavaScript-related vulnerabilities launched on three different</p><p>Android versions, including 4.1.3, 4.3.1, and 5.0. A tick (√)</p><p>implies a successful attack, whereas a cross (×) means a failed</p><p>attack. A hyphen (-) indicates that the app cannot be attacked</p><p>because it is free of the corresponding vulnerabilities or no</p><p>attack vector is exposed. We next present three case studies to</p><p>show the successful exploitation of each of the three types of</p><p>vulnerabilities.</p><p>` `Boat Browser is a popular lightweight mobile browser</p><p>whose 8.7.4 version has over 55,000 downloads. JSDroid ﬁnds</p>||<p>(a) (b)</p><p>Fig. 13. Attack case 1 (Boat browser 8.7.4; ﬁle-based cross-zone</p><p>vulnerabilities; Android 5.0).</p><p>that this version includes all three types of JavaScript-related</p><p>vulnerabilities. Here, we only describe how to exploit ﬁle-</p><p>based cross-zone vulnerabilities to attack this app. The app</p><p>opens a file:// browsing entrance for users to search for</p><p>resources on websites. As depicted in Fig. 13a, we input the</p><p>path of a local HTML ﬁle from the entrance, and we use</p><p>the app to open our specially designed page. The malicious</p><p>JavaScript code in our page is executed and performs several</p><p>cross-zone scripting operations that successfully steal contents</p><p>in a text ﬁle. As depicted in Fig. 13b, the content “abcdefg”</p>|
| :- | :- | :- | :- |
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br14"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 13

(a) (b) (a) (b)

Fig. 14. Attack case 2 (Sohu news 4.0; WebView UXSS vulnerabilities; Android 4.3.1).

||<p>in the ﬁle is displayed.</p><p>` `Sohu News is a top-10 news reading app in China. Its</p><p>4\.0 version has over 200,000,000 downloads. This version in-</p><p>volves WebView UXSS vulnerabilities, and can be attacked on</p><p>Android versions prior to 5.0. The app opens an http://</p><p>browsing entrance for users to add links to their comments.</p><p>As depicted in Fig. 14a, we input a URL from the entrance</p><p>and use the app to open our designed page. The malicious</p><p>JavaScript code on our page uses an iframe to open the Baidu</p><p>home page and to conduct a series of cross-site operations that</p><p>successfully obtain user’s cookies on the iframe page. Fig. 14b</p><p>shows that the user’s cookie in Baidu is stolen.</p><p>` `ES File Explorer is a full-featured resource manager in An-</p><p>` `droid. Its 4.0.5 version has over 3,000,000 downloads. JSDroid</p><p>ﬁnds that this version involves all three JavaScript-related</p><p>vulnerabilities. Herein, we only show its JS-to-Java interface</p><p>vulnerabilities. The app opens both file:// and http://</p><p>browsing entrances for users to search for resources in local ﬁle</p><p>systems and websites. As shown in Fig. 15a, we input a URL</p><p>from the entrance, and we use the app to open our designed</p><p>page exploiting WebView UXSS vulnerabilities. The malicious</p><p>JavaScript code on this page traverses the JavaScript context</p><p>iteratively to ﬁnd the objects (JS-to-Java interface objects) that</p><p>own the getClass() method. If such an object is found, then</p><p>` `the JavaScript code outputs its name in this page and invokes</p><p>` `the Java reﬂection mechanism to write a text ﬁle onto the users’</p><p>` `SD card. As presented in Fig. 15b, the app exposes ﬁve JS-to-</p><p>` `Java interface objects. As shown in Fig. 15c, we successfully</p><p>` `write ﬁve text ﬁles named by these objects.</p>||<p>(c)</p><p>Fig. 15. Attack case 3 (ES ﬁle explorer 4.0.5; JS-to-Java interface</p><p>vulnerabilities; Android 4.1.3).</p><p>affect versions prior to Android 5.0 and the JS-to-Java inter-</p><p>face vulnerabilities affect versions prior to Android 4.2, the</p><p>adoption of new Android versions typically takes a long time,</p><p>and a huge number of apps are still running on older versions</p><p>of Android [14]. According to Google13,14, there are 2 billion</p><p>monthly active devices on Android, and close to 10% are</p><p>running Android 4.3 or lower versions and more than 4% are</p><p>running Android 4.1 or lower versions. This indicates that the</p><p>ﬁle-based cross-zone vulnerabilities may affect 2 billion users,</p><p>and the WebView UXSS and JS-to-Java interface vulnerabilities</p><p>may still affect hundreds of millions of users.</p><p>` `Our result clearly highlights the need for Android de-</p><p>velopers to close the attack vectors by specifying more strict</p><p>permissions in the app manifest ﬁle and for Android users to</p><p>upgrade to newer Android versions. Detailed suggestions are</p><p>as follows:</p>|
| :- | :- | :- | :- |
||<p>7 DISCUSSION</p><p>Note that even when users upgrade their device/Android</p><p>versions, the JavaScript-related vulnerabilities are still severe</p><p>in practice. The reasons are as follows. Our vulnerability re-</p><p>sult demonstrates that the ﬁle-based cross-zone vulnerabilities</p><p>affect all Android versions. In January of 2108, HUAWEI</p><p>reported that nearly 25% of the top-1,000 Android apps devel-</p><p>oped by Chinese companies suffer from ﬁle-based cross-zone</p><p>vulnerabilities12. Although the WebView UXSS vulnerabilities</p><p>12\. https://testerhome.com/topics/11750, in Chinese, accessed in</p><p>03/2018.</p>||<p>• Limit JavaScript execution in ﬁle://URLs. We ﬁnd that</p><p>many apps allow WebView to execute JavaScript re-</p><p>gardless of different protocol contents loaded by We-</p><p>bView. In fact, it is unnecessary to support JavaScript</p><p>for file:// protocol contents because apps often use</p><p>this protocol to display local HTML ﬁles.</p><p>• Restrict WebView navigability. We ﬁnd that many</p><p>apps fail to correctly limit the navigability of We-</p><p>` `13. https://developer.android.com/about/dashboards/index.html, ac-</p><p>cessed in 07/2017.</p><p>` `14. https://www.theverge.com/2017/5/17/15654454/android-reaches-</p><p>2-billion-monthly-active-users, accessed in 07/2017.</p>|
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br15"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 14

||<p>myWebView.setWebViewClient(new WebViewClient()){</p><p>@Override</p><p>public boolean shouldOverrideUrlLoading(WebView view, String url</p><p>){</p><p>if (URI.parse(url).getHost().equals("www.mydomain.com")){</p><p>view.loadUrl(url);</p><p>return false ;</p><p>}</p><p>Intent intent=new Intent(Intent.ACTION VIEW);</p><p>` `intent .setData(Uri.parse(url)) ;</p><p>` `startActivity (intent) ;</p><p>return true;</p><p>}</p><p>});</p><p>Fig. 16. Example of restricting WebView navigability.</p><p>bView. Developers often use a WebViewClient to</p><p>control the navigability of a WebViewbut uninten-</p><p>tionally set WebView as navigable. A better ap-</p><p>proach is to set WebView as navigable in the method</p><p>shouldOverrideUrlLoading() only if the new</p><p>` `URL is in the same domain as the origin, as depicted</p><p>` `in Fig. 16.</p><p>• Do not expose available JS-to-Java interfaces. It is best to use</p><p>the JSBridge pattern only in Android versions higher</p><p>than 4.2. For instance, Facebook, Instagram, and</p><p>Amazon Kindle all use this approach to avoid JS-to-</p><p>Java interface vulnerabilities. If the JSBridge pattern is</p><p>required for an Android version earlier than 4.2, then</p><p>developers should remove the registered Java objects</p><p>after their use.</p><p>• Sanitize user inputs. A typical reason for successful</p><p>JavaScript injection is that developers fail to check</p><p>and ﬁlter user inputs. General input data of apps</p><p>are treated as pure texts, whereas URL data must be</p><p>sanitized to ﬁlter keywords of malicious JavaScript,</p><p>such as “script”, “iframe”, “XMLHttpRequest”</p><p>` `and “getClass”.</p><p>• Limit the attack vector. Blocking the file:// and</p><p>` `http:// browsing entrances can help effectively pre-</p><p>vent attacks. For example, Gmail and Google Text-to-</p><p>Speech use this approach to block the attack even</p><p>` `though their apps involve vulnerabilities.</p><p>• Update apps and devices. New versions of apps often</p><p>repair vulnerabilities. For instance, the latest version of</p><p>` `Adobe Reader repairs JS-to-Java interface vulnerabilities</p><p>in old versions. Moreover, higher versions of Android</p><p>devices also protect users’ privacy. As shown in Ta-</p><p>ble 11, some vulnerabilities do not exist in devices with</p><p>Android versions higher than 4.4.</p><p>• Online Vulnerability Testing. We also develop an on-</p><p>line JavaScript vulnerability testing service (publicly</p><p>available at <http://bit.ly/JSVulTest>) for users to test</p><p>their apps. According to the attack methods of each</p><p>vulnerability, we implement this service by injecting</p><p>vulnerability-exploiting JavaScript code into our spe-</p><p>cially designed webpages. When apps open these web-</p><p>pages, the JavaScript code will be executed to detect the</p><p>three types of JavaScript-related vulnerabilities and will</p><p>inform users of the detected vulnerabilities.</p>||<p>8 RELATED WORK</p><p>JavaScript-related vulnerabilities in Android have received</p><p>increasing attention in recent years [3], [4], [2], [15], [16], [17].</p><p>Our work is distinguished by presenting a systematic study</p><p>on JavaScript usage in real-world popular Android apps and</p><p>their relationships with the three classes of JavaScript-related</p><p>vulnerabilities. We review existing studies according to the</p><p>type of vulnerabilities they focus on.</p><p>` `File-based cross-zone vulnerabilities. The work by Chin</p><p>and Wagner [3] is among the ﬁrst to study this type of vulner-</p><p>ability. The work by Wu and Chang [4] studies four types of</p><p>attacks that exploit file:// vulnerabilities. However, none of</p><p>them conduct in-depth research on this type of vulnerability,</p><p>e.g., they fail to analyze the root cause and build the attack</p><p>model, and they only cover a small number of real-world apps.</p><p>` `WebView UXSS vulnerabilities. The work by Bhavani [2]</p><p>is among the ﬁrst to study cross-site scripting attacks on</p><p>Android WebView. This work analyzes Web-based APIs of</p><p>HttpClient to model potential attacks, but unfortunately, no</p><p>concrete attack model is given. A number of studies exist</p><p>on cross-site scripting vulnerabilities in Web applications [18],</p><p>[19], [20], [21], [22], as well as several approaches for mitigating</p><p>cross-site scripting attacks [15], [16]. These studies only discuss</p><p>the impact of these vulnerabilities in general Web applications,</p><p>without analyzing them within the context of Android apps.</p><p>` `JS-to-Java interface vulnerabilities. Luo et al. [17] con-</p><p>duct a small-scale manual investigation and discuss two attack</p><p>means of this type of vulnerability, including 1) malicious</p><p>webpages attacking apps, and 2) malicious apps attacking</p><p>webpages. However, attacks related to new WebView APIs are</p><p>not studied. Moreover, they do not perform any real attack.</p><p>Chin and Wagner [3] extend Luo’s work by identifying excess</p><p>authorization vulnerabilities, which is named the JS-to-Java in-</p><p>terface vulnerability in our work. Neugschwandtner et al. [23]</p><p>present some case studies on the vulnerabilities and note that</p><p>developing a static analysis tool to detect the vulnerabilities is</p><p>rewarding. Thomas et al. [14] propose an exponential decay</p><p>model for Android API vulnerabilities, which predicts that</p><p>the ﬁx of JS-to-Java interface vulnerability will not have been</p><p>deployed to 95% of devices until the end of 2017.</p><p>` `Some works study JavaScript-related vulnerabilities in</p><p>` `hybrid Web/mobile application frameworks [24], [25], [26]. Yu</p><p>` `and Yamauchi [24] ﬁrst identify security-sensitive APIs and</p><p>` `then detect threats at runtime. If threats are found, the users</p><p>` `are notiﬁed of the threats. The work by Xing et al. [25] ﬁnds</p><p>` `code injection attacks caused by cross-site scripting in HTML5-</p><p>` `based apps, particularly PhoneGap apps15. These studies inspire</p><p>our work to analyze Android hybrid frameworks and develop</p><p>a static analysis tool for detecting potential JavaScript-related</p><p>vulnerabilities in apps.</p><p>9 CONCLUSIONS</p><p>We have presented an empirical study on the top-100</p><p>most-popular real-world Android apps demonstrating that</p><p>JavaScript is widely used but that such usage may lead to</p><p>various types of security threats. We identify four JavaScript</p><p>usage patterns and three types of related vulnerabilities. For</p><p>each type of vulnerability, we present a root cause analysis</p>|
| :- | :- | :- | :- |
15\. https://phonegap.com

1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.



<a name="br16"></a>This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TDSC.2018.2845851, IEEE
 Transactions on Dependable and Secure Computing

IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 15

||<p>and build the attack model. We have also developed a static</p><p>analysis tool named JSDroid that can automatically detect</p><p>JavaScript-related vulnerabilities in Android apps. We have</p><p>applied JSDroid to 1,000 large real-world Android apps, and</p><p>we found hundreds of exploitable vulnerabilities. Moreover,</p><p>we have successfully launched real attacks on 30 of these apps.</p><p>ACKNOWLEDGMENTS</p><p>This work was supported in part by the National Key R&D</p><p>Program of China under Grant No. 2017YFB1001801, the Na-</p><p>tional Natural Science Foundation of China under Grant No.</p><p>61761136003, and the Natural Science Foundation of Jiangsu</p><p>Province under Grant No. BK20171427.</p><p>REFERENCES</p><p>[1] S. Lee, J. Dolby, and S. Ryu, “Hybridroid: static analysis framework</p><p>` `for android hybrid applications,” in Proceedings of the 31st IEEE/ACM</p><p>` `International Conference on Automated Software Engineering, ASE’16,</p><p>` `Singapore, September 3-7, 2016, pp. 250–261.</p><p>[2] A. B. Bhavani, “Cross-site scripting attacks on android webview,”</p><p>` `CoRR, vol. abs/1304.7451, 2013.</p><p>[3] E. Chin and D. Wagner, “Bifocals: Analyzing webview vulnerabilities</p><p>` `in android applications,” in Information Security Applications - 14th In-</p><p>` `ternational Workshop, WISA’13, Jeju Island, Korea, August 19-21, Revised</p><p>` `Selected Papers, 2013, pp. 138–159.</p><p>[4] D. Wu and R. K. C. Chang, “Analyzing android browser apps for</p><p>` `ﬁle: // vulnerabilities,” in Information Security - 17th International</p><p>` `Conference, ISC’14, Hong Kong, China, October 12-14. Proceedings, 2014,</p><p>` `pp. 345–363.</p><p>[5] C. Karlof, U. Shankar, J. D. Tygar, and D. A. Wagner, “Dynamic</p><p>` `pharming attacks and locked same-origin policies for web browsers,”</p><p>` `in Proceedings of the ACM Conference on Computer and Communications</p><p>` `Security, CCS’07, Alexandria, Virginia, USA, October 28-31, 2007, pp.</p><p>` `58–71.</p><p>[6] G. Yang, J. Huang, and G. Gu, “Automated generation of event-</p><p>` `oriented exploits in android hybrid apps,” in 25th Annual Network and</p><p>` `Distributed System Security Symposium, NDSS’18, San Diego, California,</p><p>` `USA, February 18 - 21, 2018.</p><p>[7] US-CERT, “Cve-2015-1275.” [https://cve.mitre.org/cgi-bin/cvename.](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1275)</p><p>[](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1275)[ ](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1275)[cgi?name=CVE-2015-1275](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1275), 2015.</p><p>[8] “Uxss vulnerability in chrome for android,” [https://bugs.chromium.]( https://bugs.chromium.org/p/chromium/issues/detail?id=144813 )</p><p>[]( https://bugs.chromium.org/p/chromium/issues/detail?id=144813 )[ ]( https://bugs.chromium.org/p/chromium/issues/detail?id=144813 )[org/p/chromium/issues/detail?id=144813.]( https://bugs.chromium.org/p/chromium/issues/detail?id=144813 )</p><p>[9] T. R. Team, “Alert: Android webview addjavascriptinterface code ex-</p><p>` `ecution vulnerability.” [http://blog.trustlook.com/2013/09/04,](http://blog.trustlook.com/2013/09/04)[ ](http://blog.trustlook.com/2013/09/04)2013.</p><p>[10] M. Backes, S. Bugiel, and E. Derr, “Reliable third-party library de-</p><p>` `tection in android and its security applications,” in Proceedings of the</p><p>` `ACM SIGSAC Conference on Computer and Communications Security,</p><p>` `Vienna, Austria, October 24-28, 2016, pp. 356–367.</p><p>[11] R. Valle´e-Rai, P. Co, E. Gagnon, L. J. Hendren, P. Lam, and V. Sundare-</p><p>` `san, “Soot - a java bytecode optimization framework,” in Proceedings</p><p>` `of the conference of the Centre for Advanced Studies on Collaborative</p><p>` `Research, November 8-11, Mississauga, Ontario, Canada, 1999, p. 13.</p><p>` `[12] A. Bartel, J. Klein, Y. L. Traon, and M. Monperrus, “Dexpler: convert-</p><p>` `ing android dalvik bytecode to jimple for static analysis with soot,”</p><p>` `in Proceedings of the ACM SIGPLAN International Workshop on State of</p><p>` `the Art in Java Program analysis, SOAP’12, Beijing, China, June 14, 2012,</p><p>` `pp. 27–38.</p><p>[13] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. L. Traon,</p><p>` `D. Octeau, and P. D. McDaniel, “Flowdroid: precise context, ﬂow,</p><p>` `ﬁeld, object-sensitive and lifecycle-aware taint analysis for android</p><p>` `apps,” in ACM SIGPLAN Conference on Programming Language Design</p><p>` `and Implementation, PLDI’14, Edinburgh, United Kingdom - June 09 - 11,</p><p>` `2014, pp. 259–269.</p><p>[14] D. R. Thomas, A. R. Beresford, T. Coudray, T. Sutcliffe, and A. Taylor,</p><p>` `“The lifetime of android API vulnerabilities: Case study on the</p><p>` `javascript-to-java interface,” in Security Protocols XXIII - 23rd Inter-</p><p>` `national Workshop, Cambridge, UK, March 31 - April 2, Revised Selected</p><p>` `Papers, 2015, pp. 126–138.</p><p>[15] I. Yusof and A. K. Pathan, “Mitigating cross-site scripting attacks with</p><p>` `a content security policy,” IEEE Computer, vol. 49, no. 3, pp. 56–63,</p><p>` `2016.</p>||<p>[16] A. Javed, J. Riemer, and J. Schwenk, “SIACHEN: A ﬁne-grained</p><p>` `policy language for the mitigation of cross-site scripting attacks,” in</p><p>` `Information Security - 17th International Conference, ISC’14, Hong Kong,</p><p>` `China, October 12-14. Proceedings, 2014, pp. 515–528.</p><p>[17] T. Luo, H. Hao, W. Du, Y. Wang, and H. Yin, “Attacks on webview</p><p>` `in the android system,” in Twenty-Seventh Annual Computer Security</p><p>` `Applications Conference, ACSAC’11, Orlando, FL, USA, 5-9 December,</p><p>` `2011, pp. 343–352.</p><p>[18] G. A. D. Lucca, A. R. Fasolino, M. Mastoianni, and P. Tramontana,</p><p>` `“Identifying cross site scripting vulnerabilities in web applications,”</p><p>` `in 6th International Workshop on Web Site Evolution (WSE’04) - Testing,</p><p>` `11 September, Chicago, IL, USA, 2004, pp. 71–80.</p><p>` `[19] G. Wassermann and Z. Su, “Static detection of cross-site scripting</p><p>` `vulnerabilities,” in 30th International Conference on Software Engineering</p><p>` `(ICSE’08), Leipzig, Germany, May 10-18, 2008, pp. 171–180.</p><p>[20] M. K. Gupta, M. C. Govil, G. Singh, and P. Sharma, “XSSDM: towards</p><p>` `detection and mitigation of cross-site scripting vulnerabilities in web</p><p>` `applications,” in International Conference on Advances in Computing,</p><p>` `Communications and Informatics, ICACCI’15, Kochi, India, August 10-13,</p><p>` `2015, pp. 2010–2015.</p><p>[21] B. Stock, S. Pﬁstner, B. Kaiser, S. Lekies, and M. Johns, “From</p><p>` `facepalm to brain bender: Exploring client-side cross-site scripting,”</p><p>` `in Proceedings of the 22nd ACM SIGSAC Conference on Computer and</p><p>` `Communications Security, Denver, CO, USA, October 12-6, 2015, pp.</p><p>` `1419–1430.</p><p>[22] L. A. Meyerovich and V. B. Livshits, “Conscript: Specifying and</p><p>` `enforcing ﬁne-grained security policies for javascript in the browser,”</p><p>` `in 31st IEEE Symposium on Security and Privacy, S&P’10, 16-19 May,</p><p>` `Berleley/Oakland, California, USA, 2010, pp. 481–496.</p><p>[23] M. Neugschwandtner, M. Lindorfer, and C. Platzer, “A view to a</p><p>` `kill: Webview exploitation,” in 6th USENIX Workshop on Large-Scale</p><p>` `Exploits and Emergent Threats, LEET ’13, Washington, D.C., USA, August</p><p>` `12, 2013.</p><p>[24] J. Yu and T. Yamauchi, “Access control to prevent malicious javascript</p><p>` `code exploiting vulnerabilities of webview in android OS,” IEICE</p><p>` `Transactions on Information & Systems, vol. 98-D, no. 4, pp. 807–811,</p><p>` `2015.</p><p>[25] X. Jin, X. Hu, K. Ying, W. Du, H. Yin, and G. N. Peri, “Code injection</p><p>` `attacks on html5-based mobile apps: Characterization, detection and</p><p>` `mitigation,” in Proceedings of the ACM SIGSAC Conference on Computer</p><p>` `and Communications Security, Scottsdale, AZ, USA, November 3-7, 2014,</p><p>` `pp. 66–77.</p><p>[26] M. Georgiev, S. Jana, and V. Shmatikov, “Breaking and ﬁxing origin-</p><p>` `based access control in hybrid web/mobile application frameworks,”</p><p>` `in 21st Annual Network and Distributed System Security Symposium,</p><p>` `NDSS’14, San Diego, California, USA, February 23-26, 2014.</p><p>Wei Song received his Ph.D. degree from Nanjing</p><p>University, China, in 2010. He is currently an asso-</p><p>ciate professor in the School of Computer Science</p><p>and Engineering, Nanjing University of Science and</p><p>Technology, China. His research interests include</p><p>software engineering and methodology, services</p><p>and cloud computing, Android application analysis,</p><p>and process mining. He is a member of the IEEE.</p><p>Qingqing Huang received her M.E. degree from</p><p>Nanjing University of Science and Technology,</p><p>China, in 2017. She is now a software engineer.</p><p>Her research interests include software engineer-</p><p>ing, program analysis, security, and JavaScript.</p><p>Jeff Huang received his PhD degree from the</p><p>Hong Kong University of Science and Technology</p><p>in 2012 and was a postdoc at the University of</p><p>Illinois at Urbana-Champaign from 2013 to 2014.</p><p>He is an assistant professor at Texas A&M Univer-</p><p>sity. His research focuses on developing practical</p><p>techniques and tools for improving software reliabil-</p><p>ity and performance. He has published extensively</p><p>in premiere software engineering conferences and</p><p>journals such as PLDI, OOPSLA, ICSE, FSE, IS-</p><p>STA, TOSEM, TSE. He is a member of the IEEE.</p>|
| :- | :- | :- | :- |
1545-5971 (c) 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications\_standards/publications/rights/index.html for more information.

[View](https://www.researchgate.net/publication/325702058)[ ](https://www.researchgate.net/publication/325702058)[publication](https://www.researchgate.net/publication/325702058)[ ](https://www.researchgate.net/publication/325702058)[stats](https://www.researchgate.net/publication/325702058)
